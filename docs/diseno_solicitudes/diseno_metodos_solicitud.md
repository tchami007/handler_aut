# Dise√±o de M√©todos de Solicitud - Handler de Autorizaci√≥n

## üìã Resumen General

Este documento detalla la arquitectura y decisiones de dise√±o para los m√©todos de procesamiento de solicitudes de movimiento en el Handler de Autorizaci√≥n.

**Fecha:** 9 de octubre de 2025  
**Versi√≥n:** 3.0 (Unificada)  
**Estado:** Implementado y Unificado

---

## üèóÔ∏è Arquitectura de Servicios

### Servicios Implementados

1. **`SolicitudService`** - Servicio principal tradicional
2. **`SolicitudCommandQueueBackgroundService`** - Procesamiento diferido
3. **`SolicitudCommandQueueInmediateService`** - Procesamiento inmediato con cola

---

## üîÑ Patrones de Procesamiento

### 1. SolicitudService (Tradicional)
```
Cliente ‚Üí Validaciones ‚Üí Actualizaci√≥n Saldo ‚Üí Registro DB ‚Üí RabbitMQ ‚Üí Respuesta
```
- **Flujo:** Secuencial completo
- **Respuesta:** Con ID de solicitud generado
- **Uso:** APIs tradicionales que requieren ID inmediato

### 2. SolicitudCommandQueueBackgroundService (Diferido)
```
Cliente ‚Üí Validaciones R√°pidas ‚Üí Respuesta Inmediata
                ‚Üì
        Cola Background ‚Üí Actualizaci√≥n Saldo ‚Üí Registro DB ‚Üí RabbitMQ
```
- **Flujo:** Validaci√≥n inmediata + procesamiento diferido
- **Respuesta:** Sin ID (se procesa despu√©s)
- **Uso:** APIs de alta performance

### 3. SolicitudCommandQueueInmediateService (H√≠brido)
```
Cliente ‚Üí Validaciones ‚Üí Actualizaci√≥n Saldo Inmediata ‚Üí Respuesta
                                    ‚Üì
                        Cola Background ‚Üí Registro DB ‚Üí RabbitMQ
```
- **Flujo:** Saldo inmediato + registro diferido
- **Respuesta:** Con saldo actualizado real
- **Uso:** Balance entre performance y consistencia

---

## üîí Configuraci√≥n de Transacciones

### Nivel de Aislamiento: SERIALIZABLE

**Decisi√≥n:** Usar `IsolationLevel.Serializable` en operaciones cr√≠ticas de saldo.

```csharp
using (var transaction = db.Database.BeginTransaction(System.Data.IsolationLevel.Serializable))
{
    // Operaciones cr√≠ticas
    transaction.Commit();
}
```

**Razones:**
- ‚úÖ **M√°xima consistencia** en operaciones concurrentes
- ‚úÖ **Previene phantom reads** y dirty reads
- ‚úÖ **Compatible con RowVersion** para control optimista
- ‚ö†Ô∏è **Trade-off:** Mayor latencia por bloqueos

### Estrategia de Entity Framework

**Configuraci√≥n:**
```csharp
// ‚ùå NO usar EnableRetryOnFailure (incompatible con transacciones manuales)
services.AddDbContext<HandlerDbContext>(options =>
    options.UseSqlServer(connectionString));
```

**Raz√≥n:** Las transacciones manuales con reintentos son incompatibles con la estrategia autom√°tica de EF Core.

---

## üîÑ Sistema de Reintentos

### Configuraci√≥n Unificada

```csharp
private readonly int cantidadReintentos = 10;
private readonly int tiempoMinimoEsperaMs = 50;
private readonly int tiempoMaximoEsperaMs = 100;
```

### Patr√≥n de Implementaci√≥n

```csharp
int reintentos = cantidadReintentos;
while (reintentos-- > 0)
{
    using (var transaction = db.Database.BeginTransaction(System.Data.IsolationLevel.Serializable))
    {
        try
        {
            // L√≥gica de negocio
            transaction.Commit();
            return resultado;
        }
        catch (DbUpdateConcurrencyException ex)
        {
            transaction.Rollback();
            if (reintentos == 0) return new SolicitudResultadoDto { Status = 98 };
            Thread.Sleep(new Random().Next(50, 100));
            continue;
        }
        catch (Exception ex) when (ex.Message.Contains("deadlock"))
        {
            transaction.Rollback();
            if (reintentos == 0) return new SolicitudResultadoDto { Status = 97 };
            Thread.Sleep(new Random().Next(50, 100));
            continue;
        }
    }
}
```

### Decisiones de Dise√±o

1. **Tiempos Aleatorios (50-100ms):** Evita sincronizaci√≥n de reintentos entre hilos
2. **10 Reintentos:** Balance entre resiliencia y latencia
3. **Rollback Expl√≠cito:** Garantiza consistencia en errores

---

## üìä C√≥digos de Estado Unificados

| **C√≥digo** | **Significado** | **Descripci√≥n** | **Acci√≥n Sugerida** |
|------------|-----------------|----------------|-------------------|
| **0** | ‚úÖ **Autorizada** | Operaci√≥n exitosa | Continuar |
| **1** | ‚ùå **Cuenta no encontrada** | N√∫mero de cuenta inv√°lido | Verificar n√∫mero |
| **2** | ‚ùå **Idempotencia** | Ya existe solicitud autorizada hoy | Verificar duplicado |
| **3** | ‚ùå **Tipo movimiento inv√°lido** | Tipo no permitido | Corregir tipo |
| **4** | ‚ùå **Saldo insuficiente** | No hay fondos suficientes | Verificar saldo |
| **5** | ‚ùå **Handler inactivo** | Sistema en mantenimiento | Reintentar despu√©s |
| **97** | ‚ùå **Error por bloqueo** | Deadlocks/timeouts persistentes | Reintentar operaci√≥n |
| **98** | ‚ùå **Error concurrencia** | Conflictos de concurrencia | Reintentar con delay |
| **99** | ‚ùå **Error cr√≠tico** | Errores no recuperables | Revisar logs |

---

## üö® Manejo de Excepciones

### Jerarqu√≠a de Captura

1. **`DbUpdateConcurrencyException`** ‚Üí Status 98
   - Control de concurrencia optimista con RowVersion
   - Reintenta autom√°ticamente

2. **Deadlocks/Timeouts/Locks** ‚Üí Status 97
   - `ex.Message.Contains("deadlock")`
   - `ex.Message.Contains("timeout")`
   - `ex.Message.Contains("lock")`
   - Reintenta con delay aleatorio

3. **Excepciones Generales** ‚Üí Status 99
   - Errores no recuperables
   - Se logea y termina

### Logging Estrat√©gico

```csharp
// Warning para reintentos
_logger.LogWarning(ex, "Conflicto detectado para cuenta {NumeroCuenta}. Reintentando... ({Reintentos} restantes)", 
    dto.NumeroCuenta, reintentos);

// Error para fallos finales
_logger.LogError(ex, "No se pudo resolver el conflicto para cuenta {NumeroCuenta} despu√©s de {CantidadReintentos} reintentos", 
    dto.NumeroCuenta, cantidadReintentos);
```

---

## üóÉÔ∏è Control de Concurrencia

### Estrategia: Concurrencia Optimista + Transacciones Serializables

#### Tabla Cuentas
```csharp
public class Cuenta
{
    public int Id { get; set; }
    public long Numero { get; set; }
    public decimal Saldo { get; set; }
    public byte[]? RowVersion { get; set; } // ‚Üê Control de concurrencia
}
```

#### Flujo de Control
1. **Lectura:** Se obtiene RowVersion actual
2. **Modificaci√≥n:** Se actualiza saldo
3. **Escritura:** EF verifica que RowVersion no cambi√≥
4. **Conflicto:** Si cambi√≥, lanza `DbUpdateConcurrencyException`
5. **Reintento:** Se vuelve a intentar con nuevos datos

---

## üîç Validaciones de Negocio

### Secuencia de Validaciones (Com√∫n a todos los servicios)

1. **Estado del Handler**
   ```csharp
   if (!statusService.EstaActivo()) return Status 5;
   ```

2. **Existencia de Cuenta**
   ```csharp
   if (cuenta == null) return Status 1;
   ```

3. **Control de Idempotencia**
   ```csharp
   var existe = db.SolicitudesDebito.Any(s =>
       s.CuentaId == cuenta.Id &&
       s.Monto == dto.Monto &&
       s.NumeroComprobante == dto.NumeroComprobante &&
       s.FechaSolicitud.Date == DateTime.UtcNow.Date &&
       s.Estado == "autorizada");
   if (existe) return Status 2;
   ```

4. **Validaci√≥n de Tipo de Movimiento**
   ```csharp
   var tiposValidos = ["debito", "credito", "contrasiento_debito", "contrasiento_credito"];
   if (!tiposValidos.Contains(dto.TipoMovimiento)) return Status 3;
   ```

5. **Validaci√≥n de Saldo Suficiente**
   ```csharp
   var esDebito = dto.TipoMovimiento == "debito" || dto.TipoMovimiento == "contrasiento_credito";
   if (esDebito && cuenta.Saldo < dto.Monto) return Status 4;
   ```

---

## üéØ Distribuci√≥n de Colas

### Algoritmo de Particionamiento

```csharp
private int CalcularCola(long numeroCuenta)
{
    if (_cantidadColas == 0) return 1;
    int resultadoModulo = (int)(numeroCuenta % _cantidadColas);
    return resultadoModulo + 1; // Las colas van de cola_1 a cola_N
}
```

**Objetivo:** Distribuir carga de manera uniforme basada en n√∫mero de cuenta.

---

## üìà M√©tricas y Monitoreo

### Logs Importantes

1. **Conflictos de Concurrencia**
   - Frecuencia de reintentos por cuenta
   - Patrones de cuentas problem√°ticas

2. **Performance**
   - Tiempo promedio de procesamiento
   - Tasa de √©xito/fallo por servicio

3. **Colas**
   - Distribuci√≥n de mensajes por cola
   - Latencia de procesamiento diferido

### Alertas Sugeridas

- **Status 97/98 > 5% del total:** Revisar concurrencia
- **Status 99 > 1% del total:** Investigar errores cr√≠ticos
- **Tiempo promedio > 500ms:** Revisar performance
- **Reintentos promedio > 3:** Revisar configuraci√≥n de base de datos

---

## üîß Configuraci√≥n de Producci√≥n

### Par√°metros Recomendados

```csharp
// Desarrollo
private readonly int cantidadReintentos = 10;
private readonly int tiempoMinimoEsperaMs = 50;
private readonly int tiempoMaximoEsperaMs = 100;

// Producci√≥n (alta concurrencia)
private readonly int cantidadReintentos = 15;
private readonly int tiempoMinimoEsperaMs = 25;
private readonly int tiempoMaximoEsperaMs = 75;
```

### Base de Datos

- **Isolation Level:** SERIALIZABLE para operaciones cr√≠ticas
- **Connection Pooling:** Configurar seg√∫n carga esperada
- **Timeouts:** Configurar timeouts adecuados para evitar bloqueos largos

---

## üìö Referencias y Evoluci√≥n

### Versiones

- **v1.0:** Implementaci√≥n b√°sica sin transacciones
- **v2.0:** Transacciones serializables + EnableRetryOnFailure (problem√°tico)
- **v3.0:** Transacciones serializables + reintentos manuales (actual)

### Lecciones Aprendidas

1. **EnableRetryOnFailure de EF Core es incompatible** con transacciones manuales
2. **Tiempos aleatorios son cruciales** para evitar sincronizaci√≥n de reintentos
3. **Isolation Serializable es necesario** para consistencia en alta concurrencia
4. **C√≥digos de error unificados** simplifican el debugging y monitoreo

### Pr√≥ximas Mejoras

- [ ] M√©tricas autom√°ticas con Prometheus
- [ ] Circuit breaker para cuentas problem√°ticas
- [ ] Cache de validaciones para mejorar performance
- [ ] Batching de operaciones para reducir contenci√≥n

---

## üöÄ Gu√≠a de Implementaci√≥n R√°pida

### Para Nuevos M√©todos de Solicitud

1. **Copiar patr√≥n de reintentos** de cualquier servicio actual
2. **Usar transacciones serializables** para operaciones de saldo
3. **Implementar c√≥digos de error unificados** (97, 98, 99)
4. **Agregar logging apropiado** para debugging
5. **Testear bajo carga** para validar concurrencia

### Checklist de Calidad

- [ ] ¬øUsa transacciones serializables?
- [ ] ¬øImplementa reintentos con tiempos aleatorios?
- [ ] ¬øManeja DbUpdateConcurrencyException?
- [ ] ¬øManeja deadlocks y timeouts?
- [ ] ¬øUsa c√≥digos de error unificados?
- [ ] ¬øIncluye logging apropiado?
- [ ] ¬øValida estado del handler?
- [ ] ¬øControla idempotencia?

---

*Documento mantido por: Sistema de Handler de Autorizaci√≥n*  
*√öltima actualizaci√≥n: 9 de octubre de 2025*